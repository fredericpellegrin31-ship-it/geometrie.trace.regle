<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Le Jeu du Trac√© - Multiplateforme</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            background-color: #f0f9ff;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-image: 
                linear-gradient(#e1e8ed 1px, transparent 1px),
                linear-gradient(90deg, #e1e8ed 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* La R√®gle */
        #ruler {
            position: absolute;
            /* La width est d√©finie en JS maintenant */
            height: 60px;
            background-color: rgba(255, 204, 102, 0.95);
            border: 2px solid #333;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transform-origin: center center;
            z-index: 5;
            cursor: grab;
            display: flex;
            align-items: flex-end;
            touch-action: none;
            transition: background-color 0.3s, opacity 0.3s, width 0.5s ease; /* Ajout transition width */
        }

        /* √âtat verrouill√© */
        #ruler.locked {
            cursor: default;
            outline: 3px solid #10B981;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
            background-color: rgba(167, 243, 208, 0.2);
            opacity: 0.4;
        }

        /* Message d'erreur si on essaie de tracer sans r√®gle */
        #error-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(239, 68, 68, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
            text-align: center;
        }
        #error-msg.visible {
            opacity: 1;
        }

        .graduation-container {
            width: 100%;
            height: 100%;
            position: relative;
            pointer-events: none;
            overflow: hidden; /* Important si on change la taille */
        }
        .tick {
            position: absolute;
            top: 0;
            background-color: black;
            width: 1px;
        }
        .tick.large { height: 15px; width: 2px; }
        .tick.medium { height: 10px; }
        .tick.small { height: 5px; }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none; 
        }

        .ui-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            z-index: 100;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            border: none;
            margin-top: 5px;
            cursor: pointer;
        }

        .gesture-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.7rem;
            color: #555;
            z-index: 50;
            white-space: nowrap;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-panel">
        <h1 id="instructionText" class="text-sm md:text-lg font-bold">Chargement...</h1>
        <p id="subText" class="text-xs text-gray-600">Initialisation du jeu</p>
        <button id="nextLevelBtn" class="btn hidden" onclick="game.nextLevel()">Niveau Suivant !</button>
    </div>

    <div id="error-msg">üîí Place d'abord la r√®gle !</div>

    <div class="gesture-hint">
        üì± 1 doigt : D√©placer | ‚úåÔ∏è 2 doigts : Tourner | üñ±Ô∏è Molette : Tourner
    </div>

    <canvas id="drawingCanvas"></canvas>
    <div id="ruler">
        <div class="graduation-container" id="rulerGraduations"></div>
    </div>
</div>

<script>
class Game {
    constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.container = document.getElementById('game-container');
        this.rulerEl = document.getElementById('ruler');
        this.errorMsg = document.getElementById('error-msg');
        
        this.rulerState = { x: 50, y: 150, rotation: 0, width: 400, height: 60, isLocked: false };
        this.level = 1;
        this.points = [];
        this.lines = [];
        this.isDrawing = false;
        this.startPoint = null;
        this.currentLineEnd = null;
        this.errorTimeout = null;

        this.activePointers = new Map();
        this.initialAngle = 0;
        this.initialRulerRotation = 0;

        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.setupEventListeners();
        this.loadLevel(1);
        this.animate();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        // On ne met pas √† jour la width ici car elle d√©pend du niveau maintenant
        this.draw();
    }

    // Mise √† jour des graduations en fonction de la taille r√©elle (pixel density constant)
    updateRulerTicks() {
        const container = document.getElementById('rulerGraduations');
        container.innerHTML = '';
        const width = this.rulerState.width;
        // Une graduation tous les 10 pixels environ
        const numTicks = Math.floor(width / 5); 
        
        for (let i = 0; i <= numTicks; i++) {
            const tick = document.createElement('div');
            tick.classList.add('tick');
            // Position en pixels
            tick.style.left = (i * 5) + 'px'; 
            
            if (i % 10 === 0) tick.classList.add('large');
            else if (i % 5 === 0) tick.classList.add('medium');
            else tick.classList.add('small');
            container.appendChild(tick);
        }
    }

    // Calcule la distance max n√©cessaire pour le niveau actuel
    calculateOptimalRulerLength() {
        let maxDist = 0;
        
        // On cherche la distance max entre deux points de m√™me couleur
        for (let i = 0; i < this.points.length; i++) {
            for (let j = i + 1; j < this.points.length; j++) {
                const p1 = this.points[i];
                const p2 = this.points[j];
                
                // Si m√™me couleur (ou niveau 1 o√π tout est connectable)
                if (p1.color === p2.color || this.level === 1) {
                    const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                    if (d > maxDist) maxDist = d;
                }
            }
        }
        
        // Marge de s√©curit√© de 100px (50px de chaque c√¥t√©)
        // Minimum 300px pour que ce soit manipulable
        return Math.max(300, maxDist + 120);
    }

    loadLevel(lvl) {
        this.level = lvl;
        this.points = [];
        this.lines = [];
        this.unlockRuler();
        document.getElementById('nextLevelBtn').classList.add('hidden');

        const w = window.innerWidth;
        const h = window.innerHeight;

        if (lvl === 1) {
            this.setUI("Niveau 1", "Place la r√®gle sous les points, valide, puis trace.");
            this.points.push(
                { x: w * 0.2, y: h * 0.4, color: 'black', id: 1 },
                { x: w * 0.8, y: h * 0.4, color: 'black', id: 2 }
            );
        } else if (lvl === 2) {
            this.setUI("Niveau 2", "Couleurs : Place, valide et trace.");
            this.points.push({ x: w * 0.15, y: h * 0.25, color: '#EF4444', id: 'r1' });
            this.points.push({ x: w * 0.5, y: h * 0.25, color: '#EF4444', id: 'r2' });
            this.points.push({ x: w * 0.75, y: h * 0.3, color: '#3B82F6', id: 'b1' });
            this.points.push({ x: w * 0.75, y: h * 0.7, color: '#3B82F6', id: 'b2' });
            this.points.push({ x: w * 0.2, y: h * 0.6, color: '#10B981', id: 'v1' });
            this.points.push({ x: w * 0.5, y: h * 0.8, color: '#10B981', id: 'v2' });
            this.points.push({ x: w * 0.1, y: h * 0.4, color: '#F59E0B', id: 'o1' });
            this.points.push({ x: w * 0.3, y: h * 0.2, color: '#F59E0B', id: 'o2' });
        } else if (lvl === 3) {
            this.setUI("Niveau 3", "Triangles : Place la r√®gle sur chaque c√¥t√©.");
            // Triangle 1
            this.points.push({ x: w * 0.2, y: h * 0.3, color: '#8B5CF6', id: 't1_1' });
            this.points.push({ x: w * 0.5, y: h * 0.3, color: '#8B5CF6', id: 't1_2' });
            this.points.push({ x: w * 0.35, y: h * 0.1, color: '#8B5CF6', id: 't1_3' });
            // Triangle 2
            this.points.push({ x: w * 0.5, y: h * 0.7, color: '#EC4899', id: 't2_1' });
            this.points.push({ x: w * 0.8, y: h * 0.7, color: '#EC4899', id: 't2_2' });
            this.points.push({ x: w * 0.65, y: h * 0.45, color: '#EC4899', id: 't2_3' });
        } else {
            this.setUI("Termin√© !", "Tu as tout r√©ussi !");
        }

        // Adapter la taille de la r√®gle
        this.rulerState.width = this.calculateOptimalRulerLength();
        this.rulerEl.style.width = this.rulerState.width + 'px';
        this.updateRulerTicks();
        
        // Reset position (centr√©)
        this.rulerState.x = (w - this.rulerState.width) / 2;
        this.rulerState.y = h * 0.8; // En bas pour commencer
        this.rulerState.rotation = 0;
        this.updateRulerUI();

        this.draw();
    }

    setUI(title, sub) {
        document.getElementById('instructionText').innerText = title;
        document.getElementById('subText').innerText = sub;
    }

    showError(msg) {
        this.errorMsg.innerText = msg;
        this.errorMsg.classList.add('visible');
        if (this.errorTimeout) clearTimeout(this.errorTimeout);
        this.errorTimeout = setTimeout(() => {
            this.errorMsg.classList.remove('visible');
        }, 2000);
    }

    setupEventListeners() {
        this.container.addEventListener('pointerdown', (e) => this.onPointerDown(e));
        window.addEventListener('pointermove', (e) => this.onPointerMove(e));
        window.addEventListener('pointerup', (e) => this.onPointerUp(e));
        window.addEventListener('pointercancel', (e) => this.onPointerUp(e));
        
        // Ajout du support de la molette pour la rotation sur ordinateur
        this.container.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
    }

    // Gestion de la rotation par molette
    onWheel(e) {
        if (this.rulerState.isLocked) return;
        
        // Emp√™che le scroll de la page si elle est scrollable
        e.preventDefault();
        
        // Rotation : signe de deltaY (haut/bas)
        // On tourne de 3 degr√©s par cran
        const direction = Math.sign(e.deltaY);
        this.rulerState.rotation += direction * 3;
        
        this.updateRulerUI();
        this.checkLock();
    }

    onPointerDown(e) {
        this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        const pt = this.getPointAt(e.clientX, e.clientY);
        
        // SI on touche un point
        if (pt) {
            // VERIFICATION : La r√®gle doit √™tre verrouill√©e pour tracer
            if (!this.rulerState.isLocked) {
                this.showError("üîí Place et valide la r√®gle d'abord !");
                return;
            }

            this.isDrawing = true;
            this.startPoint = pt;
            this.currentLineEnd = { x: e.clientX, y: e.clientY };
            return;
        }

        // Sinon, manipulation de la r√®gle (seulement si pas verrouill√©e)
        if (!this.rulerState.isLocked) {
            if (this.activePointers.size === 2) {
                const pts = Array.from(this.activePointers.values());
                this.initialAngle = Math.atan2(pts[1].y - pts[0].y, pts[1].x - pts[0].x);
                this.initialRulerRotation = this.rulerState.rotation;
            }
        }
    }

    onPointerMove(e) {
        if (!this.activePointers.has(e.pointerId)) return;
        
        const prev = this.activePointers.get(e.pointerId);
        const curr = { x: e.clientX, y: e.clientY };
        this.activePointers.set(e.pointerId, curr);

        if (this.isDrawing) {
            this.currentLineEnd = this.snapToRuler(curr);
        } else if (!this.rulerState.isLocked) {
            if (this.activePointers.size === 1) {
                this.rulerState.x += curr.x - prev.x;
                this.rulerState.y += curr.y - prev.y;
            } else if (this.activePointers.size === 2) {
                const pts = Array.from(this.activePointers.values());
                const currentAngle = Math.atan2(pts[1].y - pts[0].y, pts[1].x - pts[0].x);
                const diff = currentAngle - this.initialAngle;
                this.rulerState.rotation = this.initialRulerRotation + (diff * 180 / Math.PI);
            }
            this.updateRulerUI();
            this.checkLock();
        }
    }

    onPointerUp(e) {
        if (this.isDrawing) {
            const endPt = this.getPointAt(this.currentLineEnd.x, this.currentLineEnd.y);
            // V√©rifier validit√© du trait
            if (endPt && endPt !== this.startPoint && (endPt.color === this.startPoint.color || this.level === 1)) {
                this.lines.push({ p1: this.startPoint, p2: endPt, color: this.startPoint.color });
                this.unlockRuler();
                this.checkWin();
            }
        }
        this.isDrawing = false;
        this.startPoint = null;
        this.activePointers.delete(e.pointerId);
    }

    updateRulerUI() {
        this.rulerEl.style.transform = `translate(${this.rulerState.x}px, ${this.rulerState.y}px) rotate(${this.rulerState.rotation}deg)`;
    }

    unlockRuler() {
        this.rulerState.isLocked = false;
        this.rulerEl.classList.remove('locked');
        this.setUI(document.getElementById('instructionText').innerText, "Place la r√®gle pour le prochain trait.");
    }

    isAlreadyLinked(p1, p2) {
        return this.lines.some(l => 
            (l.p1.id === p1.id && l.p2.id === p2.id) || 
            (l.p1.id === p2.id && l.p2.id === p1.id)
        );
    }

    checkLock() {
        for (let i = 0; i < this.points.length; i++) {
            for (let j = i + 1; j < this.points.length; j++) {
                const p1 = this.points[i];
                const p2 = this.points[j];
                
                if (this.isAlreadyLinked(p1, p2)) continue;
                if (p1.color !== p2.color && this.level !== 1) continue;

                const targetAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
                const distP1 = this.getDistToRulerTopEdge(p1);
                const distP2 = this.getDistToRulerTopEdge(p2);

                let angleDiff = Math.abs((this.rulerState.rotation % 180) - (targetAngle % 180));
                if (angleDiff > 90) angleDiff = Math.abs(angleDiff - 180);

                if (angleDiff < 4 && distP1 < 20 && distP2 < 20) {
                    this.lock(p1, p2, targetAngle);
                    return;
                }
            }
        }
    }

    getDistToRulerTopEdge(p) {
        const rad = -this.rulerState.rotation * Math.PI / 180;
        const cx = this.rulerState.x + this.rulerState.width / 2;
        const cy = this.rulerState.y + this.rulerState.height / 2;
        const dx = p.x - cx;
        const dy = p.y - cy;
        const localY = dx * Math.sin(rad) + dy * Math.cos(rad);
        return Math.abs(localY - (-this.rulerState.height / 2));
    }

    lock(p1, p2, angle) {
        this.rulerState.isLocked = true;
        this.rulerEl.classList.add('locked');
        this.rulerState.rotation = angle;
        
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        
        const rad = angle * Math.PI / 180;
        // On aligne le bord HAUT de la r√®gle
        const offsetX = Math.sin(rad) * (this.rulerState.height / 2);
        const offsetY = -Math.cos(rad) * (this.rulerState.height / 2);

        const targetCenterX = midX - offsetX;
        const targetCenterY = midY - offsetY;

        this.rulerState.x = targetCenterX - (this.rulerState.width / 2);
        this.rulerState.y = targetCenterY - (this.rulerState.height / 2);
        
        this.updateRulerUI();
        this.setUI("R√®gle fix√©e !", "Tu peux maintenant tracer le trait.");
    }

    snapToRuler(pos) {
        const rad = -this.rulerState.rotation * Math.PI / 180;
        const cx = this.rulerState.x + this.rulerState.width / 2;
        const cy = this.rulerState.y + this.rulerState.height / 2;
        const dx = pos.x - cx;
        const dy = pos.y - cy;

        const localX = dx * Math.cos(rad) - dy * Math.sin(rad);
        const localY = dx * Math.sin(rad) + dy * Math.cos(rad);

        const topEdge = -this.rulerState.height / 2;
        // Magn√©tisme fort quand verrouill√©
        if (Math.abs(localY - topEdge) < 40) {
            const snappedY = topEdge;
            const fx = localX * Math.cos(-rad) - snappedY * Math.sin(-rad) + cx;
            const fy = localX * Math.sin(-rad) + snappedY * Math.cos(-rad) + cy;
            return { x: fx, y: fy };
        }
        return pos;
    }

    getPointAt(x, y) {
        return this.points.find(p => Math.hypot(p.x - x, p.y - y) < 30);
    }

    checkWin() {
        let goal = 0;
        if (this.level === 1) goal = 1;
        else if (this.level === 2) goal = 4;
        else if (this.level === 3) goal = 6;

        if (this.lines.length >= goal) {
            document.getElementById('nextLevelBtn').classList.remove('hidden');
            this.setUI("Excellent !", "Niveau termin√© !");
        }
    }

    nextLevel() {
        this.loadLevel(this.level + 1);
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.points.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
            this.ctx.fillStyle = p.color;
            this.ctx.fill();
            this.ctx.strokeStyle = "white";
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
        });

        this.lines.forEach(l => {
            this.ctx.beginPath();
            this.ctx.moveTo(l.p1.x, l.p1.y);
            this.ctx.lineTo(l.p2.x, l.p2.y);
            this.ctx.strokeStyle = l.color;
            this.ctx.lineWidth = 4;
            this.ctx.lineCap = "round";
            this.ctx.stroke();
        });

        if (this.isDrawing && this.startPoint) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.startPoint.x, this.startPoint.y);
            this.ctx.lineTo(this.currentLineEnd.x, this.currentLineEnd.y);
            this.ctx.strokeStyle = "rgba(0,0,0,0.4)";
            this.ctx.setLineDash([5, 5]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
    }

    animate() {
        this.draw();
        requestAnimationFrame(() => this.animate());
    }
}

let game;
window.onload = () => {
    game = new Game();
};
</script>
</body>
</html>




