<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Le Jeu du Trac√©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Emp√™cher le scroll et le zoom par d√©faut sur tactile */
        body {
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #f0f9ff; /* Papier bleu tr√®s clair */
            background-image: 
                linear-gradient(#e1e8ed 1px, transparent 1px),
                linear-gradient(90deg, #e1e8ed 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
        }

        /* La R√®gle - Plac√© sous le canvas (z-index: 4) */
        #ruler {
            position: absolute;
            width: 700px;
            height: 90px;
            background-color: #ffcc66;
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 2px 5px 15px rgba(0,0,0,0.2);
            transform-origin: center center;
            cursor: grab;
            z-index: 4; 
            display: flex;
            align-items: flex-end;
            touch-action: none;
            transition: outline 0.3s ease, opacity 0.3s ease;
        }

        #ruler.locked {
            cursor: default;
            outline: 4px solid #10B981; /* Vert quand verrouill√© */
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.4);
            opacity: 0.85; /* L√©g√®re transparence pour voir les points dessous si n√©cessaire */
        }

        #ruler:active:not(.locked) {
            cursor: grabbing;
            box-shadow: 4px 8px 20px rgba(0,0,0,0.3);
        }

        /* Graduations de la r√®gle */
        .graduation-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .tick {
            position: absolute;
            top: 0;
            background-color: black;
            width: 2px;
        }
        .tick.large { height: 25px; width: 3px; }
        .tick.medium { height: 15px; }
        .tick.small { height: 8px; width: 1px; }

        /* Canvas pour dessiner - Plac√© au-dessus de la r√®gle (z-index: 10) */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: auto;
        }

        /* UI */
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 30px;
            border-radius: 50px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 20;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 300px;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        .hidden { display: none !important; }

        .gesture-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            color: #555;
            pointer-events: none;
            z-index: 50;
        }

        @keyframes pop {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-panel" id="uiPanel">
        <h1 id="instructionText" class="text-xl font-bold text-gray-800">Bienvenue !</h1>
        <p id="subText" class="text-sm text-gray-600">D√©place la r√®gle pour relier les points.</p>
        <button id="nextLevelBtn" class="btn hidden" onclick="game.nextLevel()">Niveau Suivant !</button>
    </div>

    <div class="gesture-hint">
        üñê 1 doigt : D√©placer la r√®gle / Dessiner<br>
        ‚úåÔ∏è 2 doigts : Faire pivoter la r√®gle
    </div>

    <canvas id="drawingCanvas"></canvas>

    <div id="ruler">
        <div class="graduation-container" id="rulerGraduations">
            <!-- Rempli par JS -->
        </div>
    </div>
</div>

<script>
/**
 * Logique du Jeu "Le Trac√©"
 */

const CONFIG = {
    snapDistance: 35, // Distance pour coller le trac√© au bord de la r√®gle
    lockDistance: 25, // Tol√©rance de position pour le verrouillage
    lockAngle: 3,     // Tol√©rance d'angle pour le verrouillage
    pointRadius: 10,
    colors: ['#EF4444', '#3B82F6', '#10B981', '#F59E0B'] // Rouge, Bleu, Vert, Orange
};

class Game {
    constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.rulerEl = document.getElementById('ruler');
        
        this.rulerState = { x: 50, y: 300, rotation: 0, width: 700, height: 90, isLocked: false };
        
        this.level = 0;
        this.points = [];
        this.lines = [];
        this.currentLine = null;
        this.isDrawing = false;
        this.startPoint = null;

        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.initRulerVisuals();
        this.initInteractions();
        
        this.loadLevel(1);
        this.loop();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.draw();
    }

    initRulerVisuals() {
        const container = document.getElementById('rulerGraduations');
        const totalTicks = 70; 
        for (let i = 0; i <= totalTicks; i++) {
            const tick = document.createElement('div');
            tick.classList.add('tick');
            const leftPos = (i / totalTicks) * 100;
            tick.style.left = `${leftPos}%`;
            
            if (i % 10 === 0) tick.classList.add('large');
            else if (i % 5 === 0) tick.classList.add('medium');
            else tick.classList.add('small');
            
            container.appendChild(tick);
        }
        this.updateRulerTransform();
    }

    loadLevel(lvl) {
        this.level = lvl;
        this.points = [];
        this.lines = [];
        this.isDrawing = false;
        this.rulerState.isLocked = false;
        this.rulerEl.classList.remove('locked');
        document.getElementById('nextLevelBtn').classList.add('hidden');
        
        const w = window.innerWidth;
        const h = window.innerHeight;
        const cx = w / 2;
        const cy = h / 2;

        if (lvl === 1) {
            this.setInstruction("Niveau 1 : Les bases", "Place la r√®gle SOUS les points noirs. Fixe-la, puis trace.");
            this.points.push(
                { x: cx - 200, y: cy, color: 'black', id: 1 },
                { x: cx + 200, y: cy, color: 'black', id: 1 }
            );
        } 
        else if (lvl === 2) {
            this.setInstruction("Niveau 2 : Multi-couleurs", "Place la r√®gle sous une paire de m√™me couleur.");
            // Rouge (horizontal haut)
            this.points.push({ x: cx - 300, y: cy - 200, color: CONFIG.colors[0], id: 'red' });
            this.points.push({ x: cx + 50, y: cy - 200, color: CONFIG.colors[0], id: 'red' });
            // Bleu (vertical droite)
            this.points.push({ x: cx + 300, y: cy - 100, color: CONFIG.colors[1], id: 'blue' });
            this.points.push({ x: cx + 300, y: cy + 200, color: CONFIG.colors[1], id: 'blue' });
            // Vert (diagonale gauche)
            this.points.push({ x: cx - 300, y: cy + 50, color: CONFIG.colors[2], id: 'green' });
            this.points.push({ x: cx - 100, y: cy + 250, color: CONFIG.colors[2], id: 'green' });
            // Orange (diagonale centre)
            this.points.push({ x: cx - 150, y: cy - 50, color: CONFIG.colors[3], id: 'orange' });
            this.points.push({ x: cx + 150, y: cy + 100, color: CONFIG.colors[3], id: 'orange' });
        }
        else if (lvl === 3) {
            this.setInstruction("Niveau 3 : Le Triangle", "Relie les 3 points un par un.");
            this.points.push({ x: cx, y: cy - 200, color: 'black', id: 't1' });
            this.points.push({ x: cx - 200, y: cy + 150, color: 'black', id: 't2' });
            this.points.push({ x: cx + 200, y: cy + 150, color: 'black', id: 't3' });
        }
        else {
            this.setInstruction("Bravo !", "Tu as termin√© tous les niveaux !");
            this.points = [];
        }
        
        this.draw();
    }

    setInstruction(title, sub) {
        document.getElementById('instructionText').innerText = title;
        document.getElementById('subText').innerText = sub;
    }

    nextLevel() {
        this.loadLevel(this.level + 1);
    }

    checkRulerLock() {
        if (this.rulerState.isLocked) return;

        for (let i = 0; i < this.points.length; i++) {
            for (let j = i + 1; j < this.points.length; j++) {
                const p1 = this.points[i];
                const p2 = this.points[j];
                
                const alreadyLinked = this.lines.find(l => (l.p1 === p1 && l.p2 === p2) || (l.p1 === p2 && l.p2 === p1));
                if (p1.color === p2.color && !alreadyLinked) {
                    
                    const targetAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * (180 / Math.PI);
                    const distP1 = this.getDistanceFromRulerEdge(p1);
                    const distP2 = this.getDistanceFromRulerEdge(p2);

                    let diffAngle = Math.abs((this.rulerState.rotation % 180) - (targetAngle % 180));
                    if (diffAngle > 90) diffAngle = Math.abs(diffAngle - 180);

                    if (diffAngle < CONFIG.lockAngle && distP1 < CONFIG.lockDistance && distP2 < CONFIG.lockDistance) {
                        this.lockRuler(p1, p2, targetAngle);
                        return;
                    }
                }
            }
        }
    }

    getDistanceFromRulerEdge(point) {
        const rad = -this.rulerState.rotation * (Math.PI / 180);
        const rcx = this.rulerState.x + this.rulerState.width / 2;
        const rcy = this.rulerState.y + this.rulerState.height / 2;
        const dx = point.x - rcx;
        const dy = point.y - rcy;
        const localY = dx * Math.sin(rad) + dy * Math.cos(rad);
        
        // On v√©rifie la distance par rapport aux deux bords longs de la r√®gle
        const halfH = this.rulerState.height / 2;
        return Math.min(Math.abs(localY - (-halfH)), Math.abs(localY - halfH));
    }

    lockRuler(p1, p2, angle) {
        this.rulerState.isLocked = true;
        this.rulerEl.classList.add('locked');
        
        this.rulerState.rotation = angle;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        
        // On aligne le bord haut de la r√®gle sur les points
        const rad = angle * (Math.PI / 180);
        const offsetLocalY = this.rulerState.height / 2;
        this.rulerState.x = midX - (this.rulerState.width / 2);
        this.rulerState.y = midY - offsetLocalY;

        this.updateRulerTransform();
        this.setInstruction("R√®gle fix√©e !", "Les points sont bien visibles, trace ton trait maintenant !");
    }

    checkWinCondition() {
        let win = false;
        if (this.level === 1) win = this.lines.length >= 1;
        else if (this.level === 2) win = this.lines.length >= 4;
        else if (this.level === 3) win = this.lines.length >= 3;

        if (win) {
            const btn = document.getElementById('nextLevelBtn');
            btn.innerText = "Niveau Suivant ‚ûî";
            btn.classList.remove('hidden');
            this.setInstruction("Bravo !", "Tu as r√©ussi ce niveau.");
        }
    }

    initInteractions() {
        let activeTouches = new Map();
        let initialAngle = 0;
        let initialRotation = 0;
        let isDraggingRuler = false;

        const handleRulerStart = (e) => {
            if (this.isDrawing || this.rulerState.isLocked) return; 
            e.preventDefault();
            activeTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });
            this.rulerEl.setPointerCapture(e.pointerId);
            isDraggingRuler = true;

            if (activeTouches.size === 2) {
                const iterator = activeTouches.values();
                const p1 = iterator.next().value;
                const p2 = iterator.next().value;
                initialAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                initialRotation = this.rulerState.rotation;
            }
        };

        const handleRulerMove = (e) => {
            if (!activeTouches.has(e.pointerId) || this.rulerState.isLocked) return;
            const prev = activeTouches.get(e.pointerId);
            const curr = { x: e.clientX, y: e.clientY };
            activeTouches.set(e.pointerId, curr);

            if (activeTouches.size === 1) {
                this.rulerState.x += curr.x - prev.x;
                this.rulerState.y += curr.y - prev.y;
            } 
            else if (activeTouches.size === 2) {
                const points = Array.from(activeTouches.values());
                const p1 = points[0];
                const p2 = points[1];
                const currentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const angleDiff = currentAngle - initialAngle;
                this.rulerState.rotation = initialRotation + (angleDiff * 180 / Math.PI);
            }

            this.updateRulerTransform();
            this.checkRulerLock();
        };

        const handleRulerEnd = (e) => {
            activeTouches.delete(e.pointerId);
            if (activeTouches.size === 0) isDraggingRuler = false;
        };

        this.rulerEl.addEventListener('pointerdown', handleRulerStart);
        this.rulerEl.addEventListener('pointermove', handleRulerMove);
        this.rulerEl.addEventListener('pointerup', handleRulerEnd);
        this.rulerEl.addEventListener('pointercancel', handleRulerEnd);

        // Dessin (Sur le Canvas, qui est au dessus)
        const handleDrawStart = (e) => {
            // Si on touche au dessus de la r√®gle mais qu'elle n'est pas verrouill√©e, 
            // on ne dessine pas si on veut pouvoir d√©placer la r√®gle.
            // Sauf que maintenant le canvas capte tout. On v√©rifie si on est sur un point.
            const pos = this.getCanvasPos(e);
            const clickedPoint = this.getPointAt(pos.x, pos.y);
            
            if (clickedPoint) {
                this.isDrawing = true;
                this.startPoint = clickedPoint;
                this.currentLine = { start: {x: clickedPoint.x, y: clickedPoint.y}, end: pos };
            }
        };

        const handleDrawMove = (e) => {
            if (!this.isDrawing) return;
            const pos = this.getCanvasPos(e);
            this.currentLine.end = this.snapToRuler(pos);
        };

        const handleDrawEnd = (e) => {
            if (!this.isDrawing) return;
            this.isDrawing = false;
            
            const endPos = this.currentLine.end;
            const endPoint = this.getPointAt(endPos.x, endPos.y);

            if (endPoint && endPoint !== this.startPoint) {
                // M√™me couleur ou niveau sp√©cial
                if (this.startPoint.color === endPoint.color || this.level === 3 || this.level === 1) {
                    this.lines.push({
                        p1: this.startPoint,
                        p2: endPoint,
                        color: this.startPoint.color
                    });
                    this.rulerState.isLocked = false;
                    this.rulerEl.classList.remove('locked');
                    this.checkWinCondition();
                }
            }
            this.currentLine = null;
            this.startPoint = null;
        };

        this.canvas.addEventListener('pointerdown', handleDrawStart);
        window.addEventListener('pointermove', handleDrawMove);
        window.addEventListener('pointerup', handleDrawEnd);
    }

    updateRulerTransform() {
        this.rulerEl.style.transform = `translate(${this.rulerState.x}px, ${this.rulerState.y}px) rotate(${this.rulerState.rotation}deg)`;
    }

    getCanvasPos(e) {
        return { x: e.clientX, y: e.clientY };
    }

    getPointAt(x, y) {
        return this.points.find(p => Math.hypot(p.x - x, p.y - y) < 40);
    }

    snapToRuler(pos) {
        const rad = -this.rulerState.rotation * (Math.PI / 180);
        const rcx = this.rulerState.x + this.rulerState.width / 2;
        const rcy = this.rulerState.y + this.rulerState.height / 2;

        const dx = pos.x - rcx;
        const dy = pos.y - rcy;

        const localX = dx * Math.cos(rad) - dy * Math.sin(rad);
        const localY = dx * Math.sin(rad) + dy * Math.cos(rad);

        const halfH = this.rulerState.height / 2;
        const distTop = Math.abs(localY - (-halfH));
        const distBottom = Math.abs(localY - halfH);

        let snappedLocalY = localY;
        // Magn√©tisme sur le bord de la r√®gle
        if (distTop < CONFIG.snapDistance) snappedLocalY = -halfH;
        else if (distBottom < CONFIG.snapDistance) snappedLocalY = halfH;
        else return pos;

        const finalX = localX * Math.cos(this.rulerState.rotation * (Math.PI/180)) - snappedLocalY * Math.sin(this.rulerState.rotation * (Math.PI/180)) + rcx;
        const finalY = localX * Math.sin(this.rulerState.rotation * (Math.PI/180)) + snappedLocalY * Math.cos(this.rulerState.rotation * (Math.PI/180)) + rcy;

        return { x: finalX, y: finalY };
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Trac√© des lignes d√©j√† faites
        this.lines.forEach(line => {
            this.ctx.beginPath();
            this.ctx.moveTo(line.p1.x, line.p1.y);
            this.ctx.lineTo(line.p2.x, line.p2.y);
            this.ctx.strokeStyle = line.color === 'black' ? '#333' : line.color;
            this.ctx.lineWidth = 5;
            this.ctx.lineCap = 'round';
            this.ctx.stroke();
        });

        // Trac√© en cours
        if (this.currentLine && this.isDrawing) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.currentLine.start.x, this.currentLine.start.y);
            this.ctx.lineTo(this.currentLine.end.x, this.currentLine.end.y);
            this.ctx.strokeStyle = '#666';
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([5, 5]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }

        // Points (Toujours visibles au dessus)
        this.points.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, CONFIG.pointRadius, 0, Math.PI * 2);
            this.ctx.fillStyle = p.color;
            this.ctx.fill();
            this.ctx.strokeStyle = 'white';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();

            // Indicateur de s√©lection
            if (this.startPoint === p) {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, CONFIG.pointRadius + 6, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                this.ctx.stroke();
            }
        });
    }

    loop() {
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

window.onload = () => {
    window.game = new Game();
};
</script>
</body>
</html>

