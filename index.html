<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Le Jeu du Trac√© - Multiplateforme</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            background-color: #f0f9ff;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-image: 
                linear-gradient(#e1e8ed 1px, transparent 1px),
                linear-gradient(90deg, #e1e8ed 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* La R√®gle */
        #ruler {
            position: absolute;
            width: 80vw;
            max-width: 600px;
            height: 60px;
            background-color: rgba(255, 204, 102, 0.9);
            border: 2px solid #333;
            border-radius: 4px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transform-origin: center center;
            z-index: 5;
            cursor: grab;
            display: flex;
            align-items: flex-end;
            touch-action: none;
        }

        #ruler.locked {
            cursor: default;
            outline: 4px solid #10B981;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.5);
            background-color: rgba(255, 204, 102, 0.7);
        }

        .graduation-container {
            width: 100%;
            height: 100%;
            position: relative;
            pointer-events: none;
        }
        .tick {
            position: absolute;
            top: 0;
            background-color: black;
            width: 1px;
        }
        .tick.large { height: 15px; width: 2px; }
        .tick.medium { height: 10px; }
        .tick.small { height: 5px; }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
            pointer-events: none; /* Le dessin est g√©r√© par le container pour ne pas bloquer la r√®gle */
        }

        .ui-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            z-index: 100;
            text-align: center;
            width: 90%;
            max-width: 400px;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            border: none;
            margin-top: 5px;
        }

        .gesture-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.7rem;
            color: #555;
            z-index: 50;
            white-space: nowrap;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-panel">
        <h1 id="instructionText" class="text-sm md:text-lg font-bold">Chargement...</h1>
        <p id="subText" class="text-xs text-gray-600">Initialisation du jeu</p>
        <button id="nextLevelBtn" class="btn hidden" onclick="game.nextLevel()">Niveau Suivant !</button>
    </div>

    <div class="gesture-hint">
        üì± 1 doigt : D√©placer/Tracer | ‚úåÔ∏è 2 doigts : Tourner
    </div>

    <canvas id="drawingCanvas"></canvas>
    <div id="ruler">
        <div class="graduation-container" id="rulerGraduations"></div>
    </div>
</div>

<script>
class Game {
    constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.container = document.getElementById('game-container');
        this.rulerEl = document.getElementById('ruler');
        
        this.rulerState = { x: 50, y: 150, rotation: 0, width: 0, height: 60, isLocked: false };
        this.level = 1;
        this.points = [];
        this.lines = [];
        this.isDrawing = false;
        this.startPoint = null;
        this.currentLineEnd = null;

        // Gestion du tactile multi-points
        this.activePointers = new Map();
        this.initialDist = 0;
        this.initialAngle = 0;
        this.initialRulerRotation = 0;

        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.initRulerTicks();
        this.setupEventListeners();
        this.loadLevel(1);
        this.animate();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.rulerState.width = this.rulerEl.offsetWidth;
        this.rulerState.height = this.rulerEl.offsetHeight;
        this.draw();
    }

    initRulerTicks() {
        const container = document.getElementById('rulerGraduations');
        container.innerHTML = '';
        for (let i = 0; i <= 50; i++) {
            const tick = document.createElement('div');
            tick.classList.add('tick');
            tick.style.left = (i * 2) + '%';
            if (i % 10 === 0) tick.classList.add('large');
            else if (i % 5 === 0) tick.classList.add('medium');
            else tick.classList.add('small');
            container.appendChild(tick);
        }
    }

    loadLevel(lvl) {
        this.level = lvl;
        this.points = [];
        this.lines = [];
        this.rulerState.isLocked = false;
        this.rulerEl.classList.remove('locked');
        document.getElementById('nextLevelBtn').classList.add('hidden');

        const w = window.innerWidth;
        const h = window.innerHeight;

        if (lvl === 1) {
            this.setUI("Niveau 1", "Place la r√®gle sous les points noirs.");
            this.points.push(
                { x: w * 0.2, y: h * 0.4, color: 'black' },
                { x: w * 0.8, y: h * 0.4, color: 'black' }
            );
        } else if (lvl === 2) {
            this.setUI("Niveau 2", "Relie les paires de m√™me couleur.");
            // Rouge
            this.points.push({ x: w * 0.15, y: h * 0.25, color: '#EF4444', pairId: 1 });
            this.points.push({ x: w * 0.5, y: h * 0.25, color: '#EF4444', pairId: 1 });
            // Bleu
            this.points.push({ x: w * 0.75, y: h * 0.3, color: '#3B82F6', pairId: 2 });
            this.points.push({ x: w * 0.75, y: h * 0.7, color: '#3B82F6', pairId: 2 });
            // Vert
            this.points.push({ x: w * 0.2, y: h * 0.6, color: '#10B981', pairId: 3 });
            this.points.push({ x: w * 0.5, y: h * 0.8, color: '#10B981', pairId: 3 });
            // Orange
            this.points.push({ x: w * 0.1, y: h * 0.4, color: '#F59E0B', pairId: 4 });
            this.points.push({ x: w * 0.3, y: h * 0.2, color: '#F59E0B', pairId: 4 });
        } else {
            this.setUI("F√©licitations !", "Tu as termin√© tous les niveaux.");
        }
        this.draw();
    }

    setUI(title, sub) {
        document.getElementById('instructionText').innerText = title;
        document.getElementById('subText').innerText = sub;
    }

    setupEventListeners() {
        // Interaction globale pour g√©rer r√®gle ET trac√©
        this.container.addEventListener('pointerdown', (e) => this.onPointerDown(e));
        window.addEventListener('pointermove', (e) => this.onPointerMove(e));
        window.addEventListener('pointerup', (e) => this.onPointerUp(e));
        window.addEventListener('pointercancel', (e) => this.onPointerUp(e));
    }

    onPointerDown(e) {
        this.activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

        // V√©rifier si on commence √† tracer (sur un point)
        const pt = this.getPointAt(e.clientX, e.clientY);
        if (pt) {
            this.isDrawing = true;
            this.startPoint = pt;
            this.currentLineEnd = { x: e.clientX, y: e.clientY };
            return;
        }

        // Si 2 points, on pr√©pare la rotation
        if (this.activePointers.size === 2) {
            const pts = Array.from(this.activePointers.values());
            this.initialAngle = Math.atan2(pts[1].y - pts[0].y, pts[1].x - pts[0].x);
            this.initialRulerRotation = this.rulerState.rotation;
        }
    }

    onPointerMove(e) {
        if (!this.activePointers.has(e.pointerId)) return;
        
        const prev = this.activePointers.get(e.pointerId);
        const curr = { x: e.clientX, y: e.clientY };
        this.activePointers.set(e.pointerId, curr);

        if (this.isDrawing) {
            this.currentLineEnd = this.snapToRuler(curr);
        } else if (!this.rulerState.isLocked) {
            if (this.activePointers.size === 1) {
                // D√©placement simple
                this.rulerState.x += curr.x - prev.x;
                this.rulerState.y += curr.y - prev.y;
            } else if (this.activePointers.size === 2) {
                // Rotation
                const pts = Array.from(this.activePointers.values());
                const currentAngle = Math.atan2(pts[1].y - pts[0].y, pts[1].x - pts[0].x);
                const diff = currentAngle - this.initialAngle;
                this.rulerState.rotation = this.initialRulerRotation + (diff * 180 / Math.PI);
            }
            this.updateRulerUI();
            this.checkLock();
        }
    }

    onPointerUp(e) {
        if (this.isDrawing) {
            const endPt = this.getPointAt(this.currentLineEnd.x, this.currentLineEnd.y);
            if (endPt && endPt !== this.startPoint && (endPt.color === this.startPoint.color || this.level === 1)) {
                this.lines.push({ p1: this.startPoint, p2: endPt, color: this.startPoint.color });
                this.rulerState.isLocked = false;
                this.rulerEl.classList.remove('locked');
                this.checkWin();
            }
        }
        this.isDrawing = false;
        this.startPoint = null;
        this.activePointers.delete(e.pointerId);
    }

    updateRulerUI() {
        this.rulerEl.style.transform = `translate(${this.rulerState.x}px, ${this.rulerState.y}px) rotate(${this.rulerState.rotation}deg)`;
    }

    checkLock() {
        for (let i = 0; i < this.points.length; i++) {
            for (let j = i + 1; j < this.points.length; j++) {
                const p1 = this.points[i];
                const p2 = this.points[j];
                if (p1.color !== p2.color && this.level !== 1) continue;

                const targetAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
                const distP1 = this.getDistToRulerEdge(p1);
                const distP2 = this.getDistToRulerEdge(p2);

                let angleDiff = Math.abs((this.rulerState.rotation % 180) - (targetAngle % 180));
                if (angleDiff > 90) angleDiff = Math.abs(angleDiff - 180);

                if (angleDiff < 4 && distP1 < 20 && distP2 < 20) {
                    this.lock(p1, p2, targetAngle);
                    return;
                }
            }
        }
    }

    getDistToRulerEdge(p) {
        const rad = -this.rulerState.rotation * Math.PI / 180;
        const cx = this.rulerState.x + this.rulerState.width / 2;
        const cy = this.rulerState.y + this.rulerState.height / 2;
        const dx = p.x - cx;
        const dy = p.y - cy;
        const localY = dx * Math.sin(rad) + dy * Math.cos(rad);
        return Math.min(Math.abs(localY - (-this.rulerState.height / 2)), Math.abs(localY - this.rulerState.height / 2));
    }

    lock(p1, p2, angle) {
        this.rulerState.isLocked = true;
        this.rulerEl.classList.add('locked');
        this.rulerState.rotation = angle;
        const midX = (p1.x + p2.x) / 2;
        const midY = (p1.y + p2.y) / 2;
        const rad = angle * Math.PI / 180;
        // On aligne le haut de la r√®gle sur les points
        this.rulerState.x = midX - (this.rulerState.width / 2);
        this.rulerState.y = midY - (this.rulerState.height / 2);
        this.updateRulerUI();
        this.setUI("R√®gle fix√©e !", "Trace le trait maintenant.");
    }

    snapToRuler(pos) {
        const rad = -this.rulerState.rotation * Math.PI / 180;
        const cx = this.rulerState.x + this.rulerState.width / 2;
        const cy = this.rulerState.y + this.rulerState.height / 2;
        const dx = pos.x - cx;
        const dy = pos.y - cy;

        const localX = dx * Math.cos(rad) - dy * Math.sin(rad);
        const localY = dx * Math.sin(rad) + dy * Math.cos(rad);

        const halfH = this.rulerState.height / 2;
        if (Math.abs(localY - (-halfH)) < 30) {
            const snappedY = -halfH;
            const fx = localX * Math.cos(-rad) - snappedY * Math.sin(-rad) + cx;
            const fy = localX * Math.sin(-rad) + snappedY * Math.cos(-rad) + cy;
            return { x: fx, y: fy };
        }
        return pos;
    }

    getPointAt(x, y) {
        return this.points.find(p => Math.hypot(p.x - x, p.y - y) < 30);
    }

    checkWin() {
        const goal = this.level === 1 ? 1 : 4;
        if (this.lines.length >= goal) {
            document.getElementById('nextLevelBtn').classList.remove('hidden');
        }
    }

    nextLevel() {
        this.loadLevel(this.level + 1);
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Dessiner les points
        this.points.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
            this.ctx.fillStyle = p.color;
            this.ctx.fill();
            this.ctx.strokeStyle = "white";
            this.ctx.stroke();
        });

        // Dessiner les lignes valid√©es
        this.lines.forEach(l => {
            this.ctx.beginPath();
            this.ctx.moveTo(l.p1.x, l.p1.y);
            this.ctx.lineTo(l.p2.x, l.p2.y);
            this.ctx.strokeStyle = l.color;
            this.ctx.lineWidth = 4;
            this.ctx.stroke();
        });

        // Dessiner le trac√© en cours
        if (this.isDrawing && this.startPoint) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.startPoint.x, this.startPoint.y);
            this.ctx.lineTo(this.currentLineEnd.x, this.currentLineEnd.y);
            this.ctx.strokeStyle = "rgba(0,0,0,0.4)";
            this.ctx.setLineDash([5, 5]);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }
    }

    animate() {
        this.draw();
        requestAnimationFrame(() => this.animate());
    }
}

let game;
window.onload = () => {
    game = new Game();
};
</script>
</body>
</html>


