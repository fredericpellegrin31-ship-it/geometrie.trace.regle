<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Le Jeu du Trac√©</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Emp√™cher le scroll et le zoom par d√©faut sur tactile */
        body {
            overscroll-behavior: none;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #f0f9ff; /* Papier bleu tr√®s clair */
            background-image: 
                linear-gradient(#e1e8ed 1px, transparent 1px),
                linear-gradient(90deg, #e1e8ed 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
        }

        /* La R√®gle */
        #ruler {
            position: absolute;
            width: 700px; /* MODIFICATION : R√®gle plus longue (√©tait 400px) */
            height: 90px;
            background-color: #ffcc66; /* Couleur de l'image fournie */
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 2px 5px 15px rgba(0,0,0,0.2);
            transform-origin: center center;
            cursor: grab;
            z-index: 10;
            display: flex;
            align-items: flex-end; /* Graduations en bas ou haut selon besoin */
            touch-action: none;
        }

        #ruler:active {
            cursor: grabbing;
            box-shadow: 4px 8px 20px rgba(0,0,0,0.3);
        }

        /* Graduations de la r√®gle */
        .graduation-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        .tick {
            position: absolute;
            top: 0;
            background-color: black;
            width: 2px;
        }
        .tick.large { height: 25px; width: 3px; }
        .tick.medium { height: 15px; }
        .tick.small { height: 8px; width: 1px; }

        /* Canvas pour dessiner */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5; /* Sous la r√®gle */
            pointer-events: auto; /* Doit recevoir les clics si on ne touche pas la r√®gle */
        }

        /* UI */
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 30px;
            border-radius: 50px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 20;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 300px;
        }

        .btn {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        .hidden { display: none !important; }

        /* Instruction overlay for gestures */
        .gesture-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255,255,255,0.8);
            padding: 10px;
            border-radius: 10px;
            font-size: 0.8rem;
            color: #555;
            pointer-events: none;
            z-index: 50;
        }

        /* Animations */
        @keyframes pop {
            0% { transform: scale(0); opacity: 0; }
            80% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .point {
            animation: pop 0.4s ease-out forwards;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- UI -->
    <div class="ui-panel" id="uiPanel">
        <h1 id="instructionText" class="text-xl font-bold text-gray-800">Bienvenue !</h1>
        <p id="subText" class="text-sm text-gray-600">D√©place la r√®gle pour relier les points.</p>
        <button id="nextLevelBtn" class="btn hidden" onclick="game.nextLevel()">Niveau Suivant !</button>
    </div>

    <!-- Instructions Tactiles -->
    <div class="gesture-hint">
        üñê 1 doigt : D√©placer la r√®gle / Dessiner<br>
        ‚úåÔ∏è 2 doigts : Faire pivoter la r√®gle
    </div>

    <!-- Canvas pour les points et les traits -->
    <canvas id="drawingCanvas"></canvas>

    <!-- La R√®gle Interactive -->
    <div id="ruler">
        <div class="graduation-container" id="rulerGraduations">
            <!-- Rempli par JS -->
        </div>
    </div>
</div>

<script>
/**
 * Logique du Jeu "Le Trac√©"
 */

// Configuration
const CONFIG = {
    snapDistance: 30, // Distance en pixels pour "aimanter" le crayon √† la r√®gle
    pointRadius: 10,
    colors: ['#EF4444', '#3B82F6', '#10B981', '#F59E0B'] // Rouge, Bleu, Vert, Jaune
};

class Game {
    constructor() {
        this.canvas = document.getElementById('drawingCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.rulerEl = document.getElementById('ruler');
        
        // √âtat de la r√®gle
        // MODIFICATION : Width pass√©e √† 700
        this.rulerState = { x: 50, y: 300, rotation: 0, width: 700, height: 90 };
        
        // √âtat du jeu
        this.level = 0;
        this.points = [];
        this.lines = []; // Traits d√©j√† valid√©s
        this.currentLine = null; // Trait en cours de trac√©
        this.isDrawing = false;
        
        // Gestion du trac√©
        this.startPoint = null;

        // Init
        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.initRulerVisuals();
        this.initInteractions();
        
        // D√©marrer le niveau 1
        this.loadLevel(1);
        this.loop();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.draw(); // Redessiner imm√©diatement
    }

    // Cr√©ation des graduations pour ressembler √† l'image fournie
    initRulerVisuals() {
        const container = document.getElementById('rulerGraduations');
        // MODIFICATION : 70 ticks au lieu de 40 pour garder la m√™me √©chelle avec une r√®gle plus longue
        const totalTicks = 70; 
        for (let i = 0; i <= totalTicks; i++) {
            const tick = document.createElement('div');
            tick.classList.add('tick');
            const leftPos = (i / totalTicks) * 100;
            tick.style.left = `${leftPos}%`;
            
            if (i % 10 === 0) tick.classList.add('large');
            else if (i % 5 === 0) tick.classList.add('medium');
            else tick.classList.add('small');
            
            container.appendChild(tick);
        }
        this.updateRulerTransform();
    }

    /* --- Gestion des Niveaux --- */
    
    loadLevel(lvl) {
        this.level = lvl;
        this.points = [];
        this.lines = [];
        this.isDrawing = false;
        document.getElementById('nextLevelBtn').classList.add('hidden');
        
        const w = window.innerWidth;
        const h = window.innerHeight;
        const cx = w / 2;
        const cy = h / 2;

        if (lvl === 1) {
            this.setInstruction("Niveau 1 : Les bases", "Place la r√®gle sous les deux points noirs, puis trace le trait.");
            this.points.push(
                { x: cx - 200, y: cy, color: 'black', id: 1, connected: false },
                { x: cx + 200, y: cy, color: 'black', id: 1, connected: false }
            );
        } 
        else if (lvl === 2) {
            this.setInstruction("Niveau 2 : Les couleurs", "Relie les points de la m√™me couleur.");
            // Paire Rouge
            this.points.push({ x: cx - 250, y: cy - 100, color: CONFIG.colors[0], id: 'red', connected: false });
            this.points.push({ x: cx - 50, y: cy + 100, color: CONFIG.colors[0], id: 'red', connected: false });
            // Paire Bleue
            this.points.push({ x: cx + 50, y: cy - 150, color: CONFIG.colors[1], id: 'blue', connected: false });
            this.points.push({ x: cx + 250, y: cy + 50, color: CONFIG.colors[1], id: 'blue', connected: false });
        }
        else if (lvl === 3) {
            this.setInstruction("Niveau 3 : Le Triangle", "Relie les 3 points pour former un triangle.");
            this.points.push({ x: cx, y: cy - 200, color: 'black', id: 't1', connected: false });
            this.points.push({ x: cx - 200, y: cy + 150, color: 'black', id: 't1', connected: false });
            this.points.push({ x: cx + 200, y: cy + 150, color: 'black', id: 't1', connected: false });
        }
        else {
            this.setInstruction("Bravo !", "Tu as termin√© l'entra√Ænement !");
            this.points = []; // Mode libre
        }
        
        this.draw();
    }

    setInstruction(title, sub) {
        document.getElementById('instructionText').innerText = title;
        document.getElementById('subText').innerText = sub;
    }

    nextLevel() {
        this.loadLevel(this.level + 1);
    }

    checkWinCondition() {
        // Logique de victoire
        let allConnected = false;
        
        if (this.level === 1) {
            allConnected = this.lines.length >= 1;
        } else if (this.level === 2) {
            // Doit avoir 2 lignes distinctes valides
            allConnected = this.lines.length >= 2;
        } else if (this.level === 3) {
            allConnected = this.lines.length >= 3;
        }

        if (allConnected) {
            const btn = document.getElementById('nextLevelBtn');
            btn.innerText = "Bravo ! Continuer ‚ûî";
            btn.classList.remove('hidden');
            
            // Confetti effect (simple visual)
            this.setInstruction("Excellent !", "Tu as r√©ussi le trac√©.");
        }
    }

    /* --- Int√©ractions Tactiles (Le C≈ìur du Syst√®me) --- */

    initInteractions() {
        // --- 1. Gestion de la R√®gle (DOM Element) ---
        let activeTouches = new Map();
        let initialDist = 0;
        let initialAngle = 0;
        let initialRotation = 0;
        let isDraggingRuler = false;

        const handleRulerStart = (e) => {
            // Si on dessine d√©j√†, on ignore la r√®gle
            if (this.isDrawing) return; 

            e.preventDefault(); // Emp√™cher le scroll
            if (e.pointerType === 'mouse' && e.button !== 0) return;

            // Ajouter le pointeur √† la map
            activeTouches.set(e.pointerId, { x: e.clientX, y: e.clientY });
            
            // On capture le pointeur pour continuer √† tracker m√™me si on sort de la div
            this.rulerEl.setPointerCapture(e.pointerId);
            isDraggingRuler = true;

            if (activeTouches.size === 2) {
                // Initialisation pour rotation (2 doigts)
                const iterator = activeTouches.values();
                const p1 = iterator.next().value;
                const p2 = iterator.next().value;
                
                initialDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                initialAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                initialRotation = this.rulerState.rotation;
            }
        };

        const handleRulerMove = (e) => {
            if (!activeTouches.has(e.pointerId)) return;
            
            const prev = activeTouches.get(e.pointerId);
            const curr = { x: e.clientX, y: e.clientY };
            activeTouches.set(e.pointerId, curr);

            if (activeTouches.size === 1) {
                // Translation simple
                const dx = curr.x - prev.x;
                const dy = curr.y - prev.y;
                this.rulerState.x += dx;
                this.rulerState.y += dy;
            } 
            else if (activeTouches.size === 2) {
                // Rotation + Translation
                // Note: La translation avec 2 doigts est calcul√©e par la moyenne du mouvement, 
                // mais ici on va simplifier : si 2 doigts, on priorise la rotation.
                
                const points = Array.from(activeTouches.values());
                const p1 = points[0];
                const p2 = points[1];

                const currentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
                const angleDiff = currentAngle - initialAngle;
                
                // Conversion radian -> degr√©
                this.rulerState.rotation = initialRotation + (angleDiff * 180 / Math.PI);
                
                // Optionnel : D√©placer le centre de la r√®gle au centre des deux doigts
                const centerX = (p1.x + p2.x) / 2;
                const centerY = (p1.y + p2.y) / 2;
                // Ce calcul est complexe car il faut compenser l'offset, on reste sur la rotation simple pour l'instant
            }

            this.updateRulerTransform();
        };

        const handleRulerEnd = (e) => {
            activeTouches.delete(e.pointerId);
            if (activeTouches.size === 0) isDraggingRuler = false;
        };

        // Support souris molette pour rotation
        this.rulerEl.addEventListener('wheel', (e) => {
            e.preventDefault();
            this.rulerState.rotation += e.deltaY * 0.1;
            this.updateRulerTransform();
        });

        this.rulerEl.addEventListener('pointerdown', handleRulerStart);
        this.rulerEl.addEventListener('pointermove', handleRulerMove);
        this.rulerEl.addEventListener('pointerup', handleRulerEnd);
        this.rulerEl.addEventListener('pointercancel', handleRulerEnd);

        // --- 2. Gestion du Dessin (Canvas) ---
        // On dessine si on touche le canvas (pas la r√®gle)
        
        const handleDrawStart = (e) => {
            if (isDraggingRuler) return; // Priorit√© √† la r√®gle
            const pos = this.getCanvasPos(e);
            
            // V√©rifier si on touche un point de d√©part
            const clickedPoint = this.getPointAt(pos.x, pos.y);
            
            if (clickedPoint) {
                this.isDrawing = true;
                this.startPoint = clickedPoint;
                this.currentLine = { start: {x: clickedPoint.x, y: clickedPoint.y}, end: pos };
            }
        };

        const handleDrawMove = (e) => {
            if (!this.isDrawing) return;
            const pos = this.getCanvasPos(e);
            
            // LOGIQUE D'AIMANTATION √Ä LA R√àGLE
            // On projette le point sur le bord de la r√®gle
            const snappedPos = this.snapToRuler(pos);
            
            this.currentLine.end = snappedPos;
        };

        const handleDrawEnd = (e) => {
            if (!this.isDrawing) return;
            this.isDrawing = false;
            
            // Valider le trait
            const endPos = this.currentLine.end;
            const endPoint = this.getPointAt(endPos.x, endPos.y);

            // Succ√®s si : 
            // 1. On finit sur un point
            // 2. Ce n'est pas le point de d√©part
            // 3. Les couleurs correspondent (Niveau 2)
            if (endPoint && endPoint !== this.startPoint) {
                
                let validColor = true;
                if (this.level === 2 && this.startPoint.color !== endPoint.color) validColor = false;

                if (validColor) {
                    // V√©rifier si la ligne suit √† peu pr√®s la r√®gle (optionnel, pour l'√©ducation c'est mieux)
                    // Ici on valide simplement la connexion
                    this.lines.push({
                        p1: this.startPoint,
                        p2: endPoint,
                        color: this.startPoint.color
                    });
                    this.checkWinCondition();
                }
            }
            
            this.currentLine = null;
            this.startPoint = null;
        };

        this.canvas.addEventListener('pointerdown', handleDrawStart);
        window.addEventListener('pointermove', handleDrawMove);
        window.addEventListener('pointerup', handleDrawEnd);
    }

    updateRulerTransform() {
        this.rulerEl.style.transform = `translate(${this.rulerState.x}px, ${this.rulerState.y}px) rotate(${this.rulerState.rotation}deg)`;
    }

    getCanvasPos(e) {
        // Position relative au viewport
        return { x: e.clientX, y: e.clientY };
    }

    getPointAt(x, y) {
        return this.points.find(p => {
            const dist = Math.hypot(p.x - x, p.y - y);
            return dist < 30; // Zone tactile un peu plus grande que le visuel
        });
    }

    // Fonction math√©matique pour coller le trait √† la r√®gle
    snapToRuler(pos) {
        // Convertir la position en coordonn√©es locales de la r√®gle
        const rad = -this.rulerState.rotation * (Math.PI / 180);
        // Centre de la r√®gle
        const cx = this.rulerState.x + this.rulerState.width/2; 
        // Note: l'origine CSS du transform est center/center par d√©faut sur la div si on ne change rien,
        // mais ici j'utilise translate + rotate. 
        // En CSS 'translate' bouge l'√©l√©ment. Le centre visuel est x + w/2, y + h/2 ? 
        // Non, avec position absolute, x/y est le top-left avant rotation.
        // Centre de rotation :
        const rcx = this.rulerState.x + this.rulerState.width / 2;
        const rcy = this.rulerState.y + this.rulerState.height / 2;

        // Vecteur du centre vers le point
        const dx = pos.x - rcx;
        const dy = pos.y - rcy;

        // Rotation inverse pour aligner avec l'axe X local
        const localX = dx * Math.cos(rad) - dy * Math.sin(rad);
        const localY = dx * Math.sin(rad) + dy * Math.cos(rad);

        // Limites de la r√®gle en local
        const halfH = this.rulerState.height / 2;
        
        // Est-on proche du bord haut ou bas ?
        // Bord haut local = -halfH, Bord bas = +halfH
        const distTop = Math.abs(localY - (-halfH));
        const distBottom = Math.abs(localY - halfH);

        let snappedLocalY = localY;

        if (distTop < CONFIG.snapDistance) {
            snappedLocalY = -halfH; // Coller au haut
        } else if (distBottom < CONFIG.snapDistance) {
            snappedLocalY = halfH; // Coller au bas
        } else {
            return pos; // Trop loin, on ne colle pas
        }

        // Re-transformer en coordonn√©es globales
        // On garde localX inchang√© (le crayon suit le mouvement horizontal de la main)
        // On utilise snappedLocalY
        const snappedRad = -rad; // On inverse √† nouveau (donc rotation originale)
        
        // Formule rotation inverse
        const finalX = localX * Math.cos(this.rulerState.rotation * (Math.PI/180)) - snappedLocalY * Math.sin(this.rulerState.rotation * (Math.PI/180)) + rcx;
        const finalY = localX * Math.sin(this.rulerState.rotation * (Math.PI/180)) + snappedLocalY * Math.cos(this.rulerState.rotation * (Math.PI/180)) + rcy;

        return { x: finalX, y: finalY };
    }

    /* --- Boucle de rendu --- */
    
    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // 1. Dessiner les lignes valid√©es
        this.lines.forEach(line => {
            this.ctx.beginPath();
            this.ctx.moveTo(line.p1.x, line.p1.y);
            this.ctx.lineTo(line.p2.x, line.p2.y);
            this.ctx.strokeStyle = line.color || 'black';
            this.ctx.lineWidth = 4;
            this.ctx.lineCap = 'round';
            this.ctx.stroke();
        });

        // 2. Dessiner la ligne en cours
        if (this.currentLine && this.isDrawing) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.currentLine.start.x, this.currentLine.start.y);
            this.ctx.lineTo(this.currentLine.end.x, this.currentLine.end.y);
            this.ctx.strokeStyle = '#555'; // Gris crayon
            this.ctx.lineWidth = 3;
            this.ctx.setLineDash([5, 5]); // Pointill√©s pour le brouillon
            this.ctx.stroke();
            this.ctx.setLineDash([]);
        }

        // 3. Dessiner les points
        this.points.forEach(p => {
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, CONFIG.pointRadius, 0, Math.PI * 2);
            this.ctx.fillStyle = p.color;
            this.ctx.fill();
            this.ctx.strokeStyle = 'white';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();

            // Surbrillance si c'est le point de d√©part
            if (this.startPoint === p) {
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, CONFIG.pointRadius + 5, 0, Math.PI * 2);
                this.ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                this.ctx.stroke();
            }
        });
    }

    loop() {
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// D√©marrer le jeu au chargement
window.onload = () => {
    window.game = new Game();
};

</script>
</body>
</html>